<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>String扩展</title>
    <link rel="stylesheet" href="../css/code.css">
</head>
<body>
<h2>模板字符串</h2>
<p>传统的字符串实现拼接的时候，要将变量插入字符串中，语法是这样的，</p>
<div class="code">
    <p>let name = "Jacky";</p>
    <p>let occupation = "doctor";</p>
    <p>let str = "He is "+ name +",he is a "+ occupation;<span class="green">//传统字符串拼接</span></p>
</div>
<p>ES6更简捷的写法，来看一下下面这段小代码：</p>
<div class="code">
    <p>let name = "Jacky";</p>
    <p>let occupation = "doctor";</p>
    <p>//模板字符串拼接</p>
    <p>let str = `He is ${name},he is a ${occupation}`;</p>
</div>
<p>模板字符串使得我们不再需要反复使用双引号（或者单引号）了；而是改用反引号标识符（`），插入变量的时候也不需要再使用加号（+）了，而是把变量放入${ }即可。</p>
<h3>1、可以定义多行字符串</h3>
<p>传统的多行字符串写法：</p>
<div class="code">
    <p>let str = "write once ," +</p>
    <p>"run anywhere";</p>
</div>
<p>模板字符串的写法：</p>
<div class="code">
    <p>let str = `write once ,</p>
    <p>run anywhere`;</p>
</div>
<p> 直接换行即可，<span>但是要注意的是：所有的空格和所进都会被保留在输出中。</span>如果控制台输出字符串str的话，代码上换了行，控制台输出的时候也会换行。</p>
<h3>2、${ }中可以放任意的js表达式</h3>
<p>${ }中可以是运算表达式</p>
<div class="code">
    <p>var a = 1;</p>
    <p>var b = 2;</p>
    <p>var str = `the result is ${a+b}`;<span class="green">//进行加法运算 结果：the result is 3</span></p>
</div>
<p>${ }中可以是对象的属性</p>
<div class="code">
    <p>var obj = {"a":1,"b":2};</p>
    <p>var str = `the result is ${obj.a+obj.b}`;<span class="green">//结果：the result is 3</span></p>
    <p>//对象obj的属性</p>
</div>
<p>${ }中可以是函数的调用</p>
<div class="code">
    <p>function fn() {</p>
    <p>&nbsp; return 3;</p>
    <p>}</p>
    <p>var str = `the result is ${ fn() }`;<span class="green">//函数fn的调用，结果：the result is 3</span></p>
</div>
<h2>标签模板</h2>
<p>模板指的是上面讲的字符串模板，用反引号定义的字符串；而标签，则指的是一个函数，一个专门处理模板字符串的函数。</p>
<div class="code">
    <p>var name = "张三";</p>
    <p>var height  = 1.8;</p>
    <p>tagFn`他叫${name},身高${height}米。`;<span class="green">//标签+模板字符串</span></p>
    <p>function tagFn(arr,v1,v2){ <span class="green">//定义一个函数，作为标签</span></p>
    <p>&nbsp;&nbsp;console.log(arr);<span class="green">//结果：[ "他叫","，身高","米。" ]</span></p>
    <p>&nbsp;&nbsp;console.log(v1);<span class="green">//结果：张三</span></p>
    <p>&nbsp;&nbsp;console.log(v2);<span class="green">//结果：1.8</span></p>
    <p>}
</div>
<p>tagFn函数，是我们自定义的一个函数，它有三个参数分别是arr，v1，v2。函数tagFn的调用方式跟以往的不太一样，以往我们使用括号( )表示函数调用执行，这一次我们在函数名后面直接加上一个模板字符串，如下面的代码：</p>
<div class="code">
    <p>tagFn`他叫${name},身高${height}米。`;</p>
   </div>
<p> 这样就是标签模板，你可以理解为<span>标签函数+模板字符串</span>，这是一种新的语法规范。</p>
<p>第一个参数arr是数组类型，它是内容是模板字符串中除了${ }以外的其他字符，按顺序组成了数组的内容，所以arr的值是[ "他叫",  "，身高"  ,  "米。" ]；第2,3个参数则是模板字符串中对应次序的变量name和height的值。</p>
<h2>repeat函数</h2>
<p>repeat( )函数：将目标字符串重复N次，返回一个新的字符串，不影响目标字符串。</p>
<div class="code">
    <p>var name1 = "前端君";  <span class="green">//目标字符串</span></p>
    <p>var name2 =  name1.repeat(3);<span class="green">//变量name1被重复三次；</span></p>
    <p>console.log(name1);<span class="green">//结果：前端君</span></p>
    <p>console.log(name2);<span class="green">//结果：前端君前端君前端君</span></p>
</div>
<h2>includes函数</h2>
<p> includes( )函数：判断字符串中是否含有指定的子字符串，返回true表示含有和false表示未含有。第二个参数选填，表示开始搜索的位置。</p>
<div class="code">
    <p>var name = "前端君";   <span class="green"> //目标字符串</span></p>
    <p>name.includes('君');<span class="green">//true, 含有</span></p>
    <p>name.includes('web');<span class="green">//false, 不含有</span></p>
    <p>name.includes('前',1);<span class="green">//false, 从第2个字符开始搜索, 不含有</span></p>
</div>
<p> 传统的做法我们可以借助indexOf( )函数来实现，如果含有指定的字符串，indexOf( )函数就会子字符串首次出现的位置，不含有，则返回-1。我们通过返回值是否为-1来判断字符串中是否含有指定的子字符串，但是，我们现在可以用includes( )函数代替indexOf( )函数，因为它的返回值更直观（true或false），况且我们并不关心子字符串出现的位置。</p>
<p><span>注意，上面最后一句代码，第二个参数为1，表示从第2个字符“端“开始搜索，第一个字符”前“的位置是0；</span></p>
<h2>startsWith函数</h2>
<p> startsWith( )函数：判断指定的子字符串是否出现在目标字符串的开头位置，第二个参数选填，表示开始搜索的位置。</p>
<div class="code">
    <p>var name = "前端君";  <span class="green">//目标字符串</span></p>
    <p>name.startsWith('前');<span class="green">//true，出现在开头位置</span></p>
    <p>name.startsWith('端');<span class="green">//false，不是在开头位置</span></p>
    <p>name.startsWith('端',1);<span class="green">//true，从第2个字符开始</span></p>
</div>
<p>如果判断字符串是否以某个子字符串开头，就可以直接使用startsWith( )函数即可，同样，第二个参数为1表示从第2个字符开始搜索。若要从第一个字符开始搜索，参数应该为0或者为空（默认从第一个字符开始搜索）。</p>
<h2>endsWith函数</h2>
<p>  endsWith( )函数：判断子字符串是否出现在目标字符串的尾部位置，第二个参数选填，表示针对前N个字符。</p>
<div class="code">
    <p> var name = "我就是前端君";   <span class="green"> //目标字符串</span></p>
    <p> name.endsWith('我');<span class="green">//false，不在尾部位置</span></p>
    <p> name.endsWith('君');<span class="green">//true，在尾部位置</span></p>
    <p> name.endsWith('君',5);<span class="green">//false，只针对前5个字符</span></p>
    <p> name.endsWith('君',6);<span class="green">//true，针对前6个字符</span></p>
</div>
<p><span>注意，上面最后一句代码，第二个参数为6，表示针对前6个字符的尾部位置是不是“君“，第一个字符”我“的位置是1；</span></p>
<h2>codePointAt函数</h2>
<p>javascript中，一个字符固定为2个字节，对于那些需要4个字节存储的字符，javascript会认为它是两个字符，此时它的字符长度length为2。如字符："𠮷"，就是一个需要4个字节存储，length为2的字符。这会有什么问题呢？对于4字节的字符， javascript无法正确读取字符，我们来试试看。</p>
<div class="code">
    <p>var str1 = "前端";</p>
    <p>var str2 = "𠮷";</p>
    <p>str1.length;<span class="green"> //length为2</span></p>
    <p>str2.length; <span class="green">//length为2</span></p>
    <p>str1.charAt(0);<span class="green">  //前</span></p>
    <p>str1.charAt(1);<span class="green">  //端</span></p>
    <p>str2.charAt(0);<span class="green">  //'�'</span></p>
    <p>str2.charAt(1);<span class="green">  //'�'</span></p>
</div>
<p>str1和str2的长度length都是2，因为字符："𠮷"是一个4字节的字符，使用charAt函数（charAt() 方法可返回指定位置的字符）能正确读取字符串str1的字符，但无法正确读取4个字节的字符,此时返回结果出现了乱码。</p>
<p>codePointAt( )函数，就可以处理这种4个字节的字符了，我们来看看怎么使用：</p>
<div class="code">
    <p>var str = "𠮷";</p>
    <p>str.codePointAt();<span class="green">  //结果:134071</span></p>
</div>
<p>对于这个长度length为2字符："𠮷"，codePointAt( )方法可以正确地识别出它是个4个字节的字符，并且能正确地返回它的码点的十进制数：134071，这个数字抓换成16进制就是20bb7，对应的Unicode编码则是\u20bb7。</p>
<p><span> Unicode编码:Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。</span></p>
<h2>String.fromCodePoint函数</h2>
<p>String.fromCodePoint( )函数：函数的参数是一个字符对应的码点，返回的结果就是对应的字符，哪怕这个字符是一个4字节的字符，也能正确实现。</p>
<div class="code">
    <p>String.fromCodePoint(134071); <span class="green"> //结果："𠮷"</span></p>
</div>
<p>得到了我们预期的结果："𠮷"；同时也证明了上面的codePointAt( )函数能正确读取4个字节的字符。</p>
<h2>String.raw函数</h2>
<p>String.raw( )；看函数名raw是未加工的的意思，正如这个函数的作用一样：返回字符串最原始的样貌，即使字符串中含有转义符，它都视而不见，直接输出。</p>
<p>未经String.raw( )处理的字符串：</p>
<div class="code">
    <p>console.log(`hello\nworld`);<span class="green">//输出：hello</span></p>
    <p> <span class="green">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; world</span></p>

</div>
<p> \n会被识别为换行符，实现换行效果,而经过String.raw( )的同一个字符串的结果是：</p>
<div class="code">
    <p>console.log(String.raw`hello\nwolrd`);<span class="green">//输出：hello\nwolrd</span></p>
</div>
<p>   \n被识别为\和n两个字符，失去换行的效果，直接输出，这就是String.raw( )的功能。它常用来作为一个模板字符串的处理函数，也就是直接在后面加一个模板字符串。</p>
<h5>总结：ES6给字符串带来了很多实用性的扩展：模板字符串，标签模板，repeat函数、includes函数，startsWith函数，endsWith函数，codePointAt函数，String.fromCodePoint函数，String.raw函数</h5>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>数值扩展</title>
    <link rel="stylesheet" href="../css/code.css">
</head>
<body>
<h2>传统的写法</h2>
<p>在ES5中，我们存在几个全局函数 isNaN函数，isFinite函数，parseInt函数，parseFloat函数等</p>
<p>ES5中的写法是：</p>
<div class="code">
    <p>isNaN(2.5);<span class="green">//结果：false</span></p>
    <p>window.isNaN(2.5);<span class="green">//结果：false</span></p>
</div>
<p>isNaN是全局函数，本身就是属于window对象下的一个方法</p>
<p>ES6的标准中，isNaN方法被移植到了Number对象上，也就是原本属于全局对象window下的函数，现在属于Number对象上了，同样被处理的函数还有isFinite函数，parseInt函数，parseFloat函数。</p>
<p>被移植后的函数使用方式是这样的：</p>
<div class="code">
    <p>Number.isNaN(2.5); <span class="green">//结果：false</span></p>
</div>
<p>在使用之前必须指明它是Number对象下的函数，否则会被默认为window下的函数。</p>
<h2>Number.isNaN函数</h2>
<p>Number.isNaN函数：用于判断传入的是否是非数值，<span>注意：是判断非数值，而不是判断数值</span>，IsNaN的全称是： is not a number。</p>
<div class="code">
    <p>Number.isNaN(2.5); <span class="green">//结果：false</span></p>
</div>
<p> 由于2.5是一个number类型的数值，所以返回false（<span>再次注意：判断是非数值，所以是false，表示2.5是一个数值类型的值</span>）。</p>
<p>传统的isNaN函数会把非数值的参数转化成数值再进行判断，而Number. isNaN只对数值类型有效，非数值类型的参数一律返回false</p>
<div class="code">
    <p>isNaN('abc');<span class="green">//结果：true</span></p>
    <p>    <span class="green">//'abc'无法转为一个数值，返回true</span></p>
    <p>Number.isNaN('abc'); <span class="green">//结果：false</span></p>
    <p> <span class="green">//'abc'是字符串，Number.isNaN不做类型转换，直接返回false</span></p>
</div>
<p>Number下面的isNaN都懒得给字符串’abc’做类型转换，直接返回false。而ES5中的isNaN函数会对字符串’abc’进行类型转换后，发现它是一个NaN（非数值），才返回true。</p>
<p>在使用这个函数到时候还要小心，<span>当返回false的时候，不一定就是一个数值，有可能是一个非数值类型的参数。</span></p>
<h2>Number.isFinite函数  </h2>
<p>Number.isFinite函数：用来检查一个数值是否非无穷。<span>注意是判断非无穷，不是判断无穷，这里跟isNaN函数一样</span></p>
<div class="code">
    <p>Number.isFinite(1);<span class="green">//结果：true，数值1是有穷，即非无穷</span></p>
    <p>Number.isFinite(Infinity);<span class="green">//结果：false，Infinity表示无穷大的特殊值</span></p>
</div>
<p>注意第二行代码的参数：Infinity，Infinity是window对象下的一个常量，表示一个无穷数。所以第二行代码会返回false。此外，isFinite函数跟isNaN函数一样，也只是对数值类型有效，对非数值类型的参数一律返回false。</p>
<p><span>当Number.isFinite函数返回false的时候，参数不一定就是一个有穷的数值类型，也有可能是一个非数值类型的参数。如：字符串’abc’。</span></p>
<h2>Number.parseInt函数  </h2>
<p>parseInt函数：解析一个字符串，返回一个整数。parseInt函数同样是从window对象下移植到Number对象下，但是它的作用没有任何变化。</p>
<div class="code">
    <p><span>//传统用法：</span></p>
    <p>parseInt('12.3abc');<span class="green">//结果：返回数值12</span></p>
    <p><span>//ES6用法：</span></p>
    <p>Number.parseInt('12.3abc');<span class="green">//结果：返回数值12</span></p>
</div>
<h2>Number.parseFloat函数  </h2>
<p> parseFloat函数：解析一个字符串，并返回一个浮点数。跟parseInt一样，被移植到Number对象下，作用保持不变。</p>
<div class="code">
    <p><span>//传统用法：</span></p>
    <p>parseFloat('12.3abc');<span class="green">//结果：返回数值12.3</span></p>
    <p><span>//ES6用法：</span></p>
    <p>Number.parseFloat('12.3abc');<span class="green">//结果：返回数值12.3</span></p>
</div>
<p>以上4个函数都是在window对象下，移植到了Number对象下，这么做的目的是慢慢地减少全局性的函数，把全局函数合理地规划到其他对象下，渐渐实现语言的模块化。</p>
<h2>Number.isInteger函数  </h2>
<p>Number.isInteger函数：用来判断是否是整数。</p>
<div class="code">
    <p>Number.isInteger(3.2);<span class="green">//结果：false</span></p>
    <p>Number.isInteger(3);<span class="green">//结果：true</span></p>
</div>
<p>数值3.2不是整数，返回false。不过有一点要注意：<span>在javascript内部对整数和浮点数采用一样的存储方式，因此小数点后如果都是0的浮点数，都会被认为是整数</span>。看个例子就知道了：</p>
<div class="code">
    <p>Number.isInteger(3.0);<span class="green">//结果：true</span></p>
    <p>Number.isInteger(3.00);<span class="green">//结果：true</span></p>
</div>
<p>数值3.0和3.00都会被认为是整数。</p>
<h2>极小常量</h2>
<h3>Number.EPSILON常量</h3>
<p>Number.EPSILON常量：定义一个极小的数值。</p>
<div class="code">
   <p>console.log(Number.EPSILON);<span class="green">//结果：2.220446049250313e-16</span></p>
</div>
<p>Number.EPSILON的出现是用来判断浮点数的计算误差，如果浮点数计算得到的误差不超过Number.EPSILON的值，就表示可以接受这样的误差。</p>
<h2>安全整数</h2>
<p>原来JavaScript能够准确表示的整数范围在-2^53到2^53之间，超过这个范围，无法精确表示这个值。故称之为不安全。</p>
<p>ES6定义了两个常量来表示这个范围的最大值和最小值：Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER。</p>
<div class="code">
   <p> Number.isSafeInteger(Number.MAX_SAFE_INTEGER);<span class="green">//结果：true</span></p>
   <p> Number.isSafeInteger(Number.MAX_SAFE_INTEGER+1);<span class="green">//结果：false</span></p>
</div>
<p>用最大安全整数Number.MAX_SAFE_INTEGER来做试验，第一行代码的结果返回的值是true，也就表示Number.MAX_SAFE_INTEGER属于安全范围，第二行代码，我们对Number.MAX_SAFE_INTEGER进行了+1，相加后的数值超过安全范围，isSafeInteger函数就返回了false，表示不在安全范围内。</p>
<h2>Math.trunc函数</h2>
<p>Math.trunc函数：用于去除一个数的小数部分，返回整数部分。</p>
<div class="code">
    <p>Math.trunc(3);<span class="green">//结果：3</span></p>
    <p>Math.trunc(3.1);<span class="green">//结果：3</span></p>
</div>
<h2>Math.sign函数</h2>
<p>Math.sign函数：用来判断一个数到底是正数、负数、还是零。</p>
<div class="code">
    <p>Math.sign(3);<span class="green">//结果：1</span></p>
    <p>Math.sign(-3);<span class="green">//结果：-1</span></p>
    <p>Math.sign(0);<span class="green">//结果：0</span></p>
    <p>Math.sign('abc');<span class="green">//结果：NaN</span></p>
</div>
<p>参数如果是正数，结果返回1；如果是负数，结果返回-1；如果是0，结果返回0；如果是一个非数值类型的参数，结果返回：NaN。</p>
<h2>Math.cbrt函数</h2>
<p>Math.cbrt函数：用于计算一个数的立方根。</p>
<div class="code">
    <p>Math.cbrt(8);<span class="green">//结果：2</span></p>
    <p>Math.cbrt(27);<span class="green">//结果：3</span></p>
</div>

<h5>Math.acosh(x) 返回 x 的反双曲余弦。</h5>
    <h5>Math.asinh(x) 返回 x 的反双曲正弦。</h5>
    <h5>Math.atanh(x) 返回 x 的反双曲正切。</h5>
    <h5>Math.clz32(x) 返回 x 的 32 位二进制整数表示形式的前导 0 的个数。</h5>
    <h5>Math.sinh(x) 返回x的双曲正弦。</h5>
    <h5>Math.cosh(x) 返回 x 的双曲余弦。</h5>
    <h5>Math.expm1(x) 返回 eˆx - 1。</h5>
    <h5>Math.fround(x) 返回 x 的单精度浮点数形式。</h5>
    <h5>Math.hypot(...values) 返回所有参数的平方和的平方根。</h5>
    <h5>Math.imul(x, y) 返回两个参数以 32 位整数形式相乘的结果。</h5>
    <h5>Math.log1p(x) 返回 1 + x 的自然对数。</h5>
    <h5>Math.log10(x) 返回以 10 为底的x的对数。</h5>
    <h5>Math.log2(x) 返回以 2 为底的 x 的对数。</h5>
    <h5>Math.tanh(x) 返回 x 的双曲正切。</h5>
    <h5>Math.random();</h5>

<h5>总结：ES6对Number对象新增了isInteger函数、极小常量Number.EPSILON、安全整数；还将window对象下的4个函数移植到了Number对象下；此外，对Math对象扩展了17个新函数。</h5>




















</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>解构赋值</title>
    <link rel="stylesheet" href="../css/code.css">
</head>
<body>
<h2>解构赋值</h2>
<p><span>从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）</span></p>
<p>关于给变量赋值，传统的变量赋值是这样的：</p>
<div class="code">
    <p>var arr = [1,2,3];<span class="green">//把数组的值分别赋给下面的变量；</span></p>
    <p>var a = arr[0];</p>
    <p>var b = arr[1];</p>
    <p>var c = arr[2];</p>

    <p>console.log(a);<span class="green">//a的值为1</span></p>
    <p>console.log(b);<span class="green">//b的值为2</span></p>
    <p>console.log(c);<span class="green">//c的值为3</span></p>
</div>
<p>  将数组的元素值1，2，3分别赋值给变量a，b，c，结果也是如我们所愿，赋值成功，这是一种传统的赋值方式。</p>
<p>变量的解构赋值：</p>
<div class="code">
    <p> var [a,b,c] = [1,2,3]; <span class="green">//把数组的值分别赋给下面的变量；
    <p>console.log(a);<span class="green">//a的值为1</span></p>
    <p>console.log(b);<span class="green">//b的值为2</span></p>
    <p>console.log(c);<span class="green">//c的值为3</span></p>
</div>
<p>不需要分别把变量a，b，c分别声明定义和赋值，只需要将变量a，b，c作为一个数组的元素，然后将数组[1,2,3]赋值给数组[a,b,c]即可，变量a，b，c即可分别得到对应的值。<span>数组的解构赋值。</span></p>
<h2>数组的解构赋值</h2>
<h3>1、结构赋值可以嵌套的</h3>
<div class="code">
    <p>var [ a,b,[ c1,c2 ] ] = [ 1,2,[ 3.1,3.2 ] ];</p>
    <p>console.log(c1);<span class="green">//结果：c1的值为3.1</span></p>
    <p>console.log(c2);<span class="green">//结果：c2的值为3.2</span></p>
</div>
<p>数组中即使再嵌套另一个数组，结构赋值也能为我们的变量准确的赋值，c1和c2的值分别为3.1 , 3.2，也就是赋值成功。</p>
<h3>2、不完全解构</h3>
<div class="code">
    <p>var [a,b,c] = [1,2];</p>
    <p>console.log(a);<span class="green">//结果：a的值为1</span></p>
    <p>console.log(b);<span class="green">//结果：b的值为2</span></p>
</div>
<p>当左边的模式（你可以理解为格式）与右边 <span>不完全一样</span>的时候，那么赋值过程中，只会给模式匹配成功的部分的变量赋值，例如：变量c没有在右边找到匹配的模式，所以无法进行赋值，但这并不影响变量a和变量b的赋值，因为它们在右边找到与之匹配的模式，这种叫做<span>不完全解构</span>。</p>
<h3>赋值不成功，变量的值为undefined</h3>
<div class="code">
    <p>var [a,b,c] = [1,2];</p>
    <p>console.log(a);<span class="green">//结果：a的值为1</span></p>
    <p>console.log(b);<span class="green">//结果：b的值为2</span></p>
    <p>console.log(c);<span class="green">//结果：c的值为undefined</span></p>
</div>
<p>变量a和变量b为不完全解构，那么变量c <span>解构不成功，变量的值就等于undefined。</span>相当于只声明了变量c，但是没赋值。</p>
<h3>4.允许设定默认值</h3>
<div class="code">
    <p>var [a,b,c=3] = [1,2];</p>
    <p>console.log(a);<span class="green">//结果:a的值为1</span></p>
    <p>console.log(b);<span class="green">//结果:b的值为2</span></p>
    <p>console.log(c);<span class="green">//结果:c的值为3</span></p>
</div>
<p>变量c已经指定默认值为3，即使右侧没有与之对应的值赋给它也没关系，它都可以成功赋值为3，如果你想覆盖默认值3，只需赋一个有效的值即可</p>
<div class="code">
   <p>var [a,b,c=3] =[1,2,4];</p>
   <p>console.log(a);<span class="green">//结果:a的值为1</span></p>
   <p>console.log(b);<span class="green">//结果:b的值为2</span></p>
   <p>console.log(c);<span class="green">//结果:c的值为4</span></p>
</div>
<p>这个时候默认值3会被新的值4覆盖，c的值为4；<span>注意：当新的值为undefined的时候，是不会覆盖默认值的。</span></p>
<h2>对象的解构赋值 </h2>
<p> 对象的解构赋值跟数组的解构赋值很类似</p>
<div class="code">
    <p>var { a,b,c} = {"a":1,"b":2,"c":3};</p>
    <p>console.log(a);<span class="green">//结果：a的值为1</span></p>
    <p>console.log(b);<span class="green">//结果：b的值为2</span></p>
    <p>console.log(c);<span class="green">//结果：c的值为3</span></p>
</div>
<p>对象的解构赋值不会受到属性的排列次序影响（数组则会受影响），它是跟属性名关联起来的，变量名要和属性名一致，才会成功赋值。</p>
<p>如果变量找不到与其名字相同的属性，就会赋值不成功,如下</p>
<div class="code">
    <p>var { a } = {"b":2};</p>
    <p>console.log(a);<span class="green">//结果：a的值为undefined</span></p>
</div>
<p>变量a在右侧找不到与之名字匹配的属性a，所以变量a赋值不成功，a的值为undefined。</p>
<p>如果你想给一个变量名与属性名不一样的变量解构赋值，可以这样写：</p>
<div class="code">
    <p>var { b:a,} = {"b":2};</p>
    <p>console.log(a);<span class="green">//结果：a的值为2</span></p>
</div>
<h3>1、对象解构赋值也可以嵌套</h3>
<div class="code">
    <p>var {a:{b}} = {"a":{"b":1}};</p>
    <p>console.log(b);<span class="green">//结果：b的值为1</span></p>
</div>
<h3>2、可以指定默认值</h3>
<div class="code">
    <p>var {a,b=2} = {"a":1};</p>
    <p>console.log(b);<span class="green">//结果：b的值为默认值2</span></p>
</div>
<h2>字符串的解构赋值</h2>
<div class="code">
    <p>var [a,b,c,d,e,f] = "我就是前端君";</p>
    <p>console.log(a);<span class="green">//我</span></p>
    <p>console.log(b);<span class="green">//就</span></p>
    <p>console.log(c);<span class="green">//是</span></p>
    <p>console.log(d);<span class="green">//前</span></p>
    <p>console.log(e);<span class="green">//端</span></p>
    <p>console.log(f);<span class="green">//君</span></p>
</div>
<p>因为在解构赋值的过程中，字符串被转换成了一个类似数组的对象。变量a，b，c，d，e，f都分别赋上了对应的值。</p>
<h2>解构赋值的用途</h2>
<h3>一、交换变量的值</h3>
<p>传统做法最常用的是引入第三个变量来临时存放，如下：</p>
<div class="code">
    <p>var x = 1;</p>
    <p>var y = 2;</p>
    <p>var z = x;<span class="green">//第三个变量临时存放x的值</span></p>
    <p>x = y; <span class="green"> //把y的值赋给x；</span></p>
    <p>y = z;  <span class="green">//把z的值赋值给y；</span></p>
    <p>console.log(x); <span class="green">//结果：x为2</span></p>
    <p>console.log(y); <span class="green">//结果：y为1</span></p>
</div>
<p>解构赋值交换两个变量的值。看下面的代码：</p>
<div class="code">
    <p>var x = 1;</p>
    <p>var y = 2;</p>
    <p>[x,y] = [y,x];</p>
    <p>console.log(x1);<span class="green">//结果：x为2</span></p>
    <p>console.log(y1);<span class="green">//结果：y为1</span></p>
</div>
<h3>二、提取函数返回的多个值</h3>
<p>函数只能返回一个值，我们可以将多个值装在一个数组或者对象中，再用解构赋值快速提取其中的值。</p>
<div class="code">
    <p>function demo(){</p>
    <p>&nbsp; return {"name":"张三","age":21}</p>
    <p>}</p>
    <p>var {name,age} = demo();</p>
    <p>console.log(name);<span class="green">//结果：张三</span></p>
    <p>console.log(age); <span class="green">//结果：21</span></p>
</div>
<p>将demo函数的运行结果直接通过结构赋值赋给变量name和age，实现快速的提取对应的值。</p>
<h3>三、定义函数参数</h3>
<div class="code">
    <p>function demo({a,b,c}){</p>
    <p>&nbsp;console.log("姓名："+ a);<span class="green">//结果：张三</span></p>
    <p>&nbsp;console.log("身高："+ b);<span class="green">//结果：1.72m</span></p>
    <p>&nbsp;console.log("体重："+ c);<span class="green">//结果：50kg</span></p>
    <p>}</p>
    <p>demo({a:"张三",b:"1.72m",c:"50kg",d:"8000"});</p>
</div>
<p>通过这种写法， 很方便就能提取JSON对象中想要的参数，例如案例中，我们只需要获取实参中的：a，b，c，而不需要关其他的参数，比如：d或者其他更多的参数。</p>
<h3>四、函数参数的默认值</h3>
<p>传统的参数默认值的实现方式是，先判断该参数是否为undefined，如果是代表没传，需要手动给它赋一个值，如</p>
<div class="code">
    <p>function demo(a){</p>
    <p>&nbsp;&nbsp;var name;</p>
    <p>&nbsp;&nbsp;if(a === undefined){<span class="green">//判断参数书否是否传值</span></p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;name= "张三"; <span class="green">//没传，赋默认值</span></p>
    <p>&nbsp;&nbsp;}else{</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;name= a;<span class="green">//将name=“李四”赋给name</span></p>
    <p>&nbsp;&nbsp;}</p>
    <p>&nbsp;&nbsp;console.log(name);<span class="green">//结果：李四</span></p>
    <p>}</p>
    <p>demo({"name":"李四","age":23});<span class="green">//传入参数</span></p>
</div>
<p>解构赋值，看下面的代码：</p>
<div class="code">
    <p>function demo({name="张三"}){</p>
    <p>console.log("姓名："+name);<span class="green">//结果为默认值：姓名：张三</span></p>
    <p>}</p>
    <p>demo({});<span class="green">//没传入参数</span></p>
</div>
<p>函数调用的时候没有传入对应的name参数，此时name就会使用默认值：“张三”</p>
<h5>总结：解构赋值给我们一种新的变量赋值方式，主要可以利用数组解构赋值和对象解构赋值。它的用途包括：交换变量值，提取函数返回值，函数参数定义，默认值设定等等，都给我们编程带来便利，在未来的代码中会见到越来越多人使用这个新特性。</h5>
</body>
</html>